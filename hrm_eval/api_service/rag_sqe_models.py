"""
Pydantic models for RAG + SQE API endpoints.

Additional request/response models for RAG-enhanced and SQE-orchestrated test generation.
"""

from pydantic import BaseModel, Field
from typing import List, Optional, Dict, Any
from enum import Enum

from ..requirements_parser.schemas import Epic, TestCase


class GenerationMode(str, Enum):
    """Test generation mode."""
    HRM_ONLY = "hrm_only"
    SQE_ONLY = "sqe_only"
    HYBRID = "hybrid"


class MergeStrategy(str, Enum):
    """Strategy for merging HRM and SQE results."""
    WEIGHTED = "weighted"
    UNION = "union"
    INTERSECTION = "intersection"


class RAGGenerationOptions(BaseModel):
    """Options for RAG-enhanced generation."""
    use_rag: bool = Field(True, description="Enable RAG context retrieval")
    use_sqe: bool = Field(True, description="Enable SQE agent orchestration")
    generation_mode: GenerationMode = Field(
        GenerationMode.HYBRID,
        description="Generation mode: hrm_only, sqe_only, or hybrid"
    )
    merge_strategy: MergeStrategy = Field(
        MergeStrategy.WEIGHTED,
        description="Strategy for merging results"
    )
    top_k_similar: int = Field(5, ge=1, le=20, description="Number of similar tests to retrieve")
    min_similarity: float = Field(0.7, ge=0.0, le=1.0, description="Minimum similarity threshold")
    hrm_weight: float = Field(0.6, ge=0.0, le=1.0, description="Weight for HRM results")
    sqe_weight: float = Field(0.4, ge=0.0, le=1.0, description="Weight for SQE results")
    auto_index: bool = Field(True, description="Automatically index generated tests")


class RAGGenerationRequest(BaseModel):
    """Request for RAG-enhanced test generation."""
    epic: Epic = Field(..., description="Epic with user stories")
    options: Optional[RAGGenerationOptions] = Field(
        None,
        description="RAG generation options"
    )


class RAGMetadata(BaseModel):
    """Metadata for RAG-enhanced generation."""
    generation_mode: str = Field(..., description="Mode used for generation")
    hrm_generated: int = Field(..., description="Number of tests generated by HRM")
    sqe_generated: int = Field(0, description="Number of tests generated by SQE")
    merged_count: int = Field(..., description="Final number of test cases after merging")
    rag_context_used: bool = Field(..., description="Whether RAG context was used")
    rag_similar_count: int = Field(0, description="Number of similar tests retrieved")
    sqe_enhanced: bool = Field(..., description="Whether SQE agent was used")
    merge_strategy: str = Field("", description="Merge strategy used")
    generation_time_seconds: float = Field(..., description="Total generation time")
    workflow_steps: int = Field(0, description="Number of workflow steps executed")


class RAGGenerationResponse(BaseModel):
    """Response for RAG-enhanced test generation."""
    test_cases: List[TestCase] = Field(..., description="Generated test cases")
    metadata: RAGMetadata = Field(..., description="Generation metadata")
    coverage_analysis: Dict[str, Any] = Field(
        default_factory=dict,
        description="Coverage analysis report"
    )
    recommendations: List[str] = Field(
        default_factory=list,
        description="Recommendations for improving test coverage"
    )
    status: str = Field(..., description="Generation status")


class IndexTestCasesRequest(BaseModel):
    """Request to index test cases into vector store."""
    test_cases: List[TestCase] = Field(..., description="Test cases to index")
    source: str = Field("api_upload", description="Source identifier")
    batch_size: int = Field(100, ge=1, le=500, description="Batch size for indexing")


class IndexingStats(BaseModel):
    """Statistics for indexing operation."""
    total_indexed: int = Field(..., description="Total number of test cases indexed")
    batch_count: int = Field(..., description="Number of batches processed")
    indexing_time_seconds: float = Field(..., description="Time taken for indexing")
    errors: int = Field(0, description="Number of errors encountered")


class IndexTestCasesResponse(BaseModel):
    """Response for test case indexing."""
    status: str = Field(..., description="Indexing status")
    stats: IndexingStats = Field(..., description="Indexing statistics")
    message: str = Field(..., description="Status message")


class SimilarTestSearchRequest(BaseModel):
    """Request to search for similar test cases."""
    query: Optional[str] = Field(None, description="Text query for search")
    requirement: Optional[Dict[str, Any]] = Field(None, description="Requirement dictionary")
    top_k: int = Field(5, ge=1, le=20, description="Number of results to return")
    min_similarity: float = Field(0.7, ge=0.0, le=1.0, description="Minimum similarity threshold")


class SimilarTest(BaseModel):
    """Similar test case result."""
    test_case: Dict[str, Any] = Field(..., description="Test case data")
    similarity_score: float = Field(..., description="Similarity score")
    source: str = Field("", description="Source of the test case")


class SimilarTestSearchResponse(BaseModel):
    """Response for similar test search."""
    results: List[SimilarTest] = Field(..., description="Similar test cases found")
    query_info: Dict[str, Any] = Field(..., description="Query information")
    search_time_seconds: float = Field(..., description="Search time")


class WorkflowExecutionRequest(BaseModel):
    """Request to execute a complete workflow."""
    epic: Epic = Field(..., description="Epic with user stories")
    workflow_type: str = Field("full", description="Type of workflow: full, generate_only, validate_only")
    rag_options: Optional[RAGGenerationOptions] = Field(None, description="RAG options")


class WorkflowStep(BaseModel):
    """Individual workflow step result."""
    step: str = Field(..., description="Step name")
    status: str = Field(..., description="Step status")
    result: Dict[str, Any] = Field(default_factory=dict, description="Step result")
    duration_seconds: float = Field(0.0, description="Step duration")


class WorkflowExecutionResponse(BaseModel):
    """Response for workflow execution."""
    workflow_type: str = Field(..., description="Type of workflow executed")
    steps: List[WorkflowStep] = Field(..., description="Workflow steps executed")
    test_cases: List[TestCase] = Field(default_factory=list, description="Generated test cases")
    status: str = Field(..., description="Workflow status")
    total_time_seconds: float = Field(..., description="Total workflow time")


class RAGHealthCheck(BaseModel):
    """RAG system health check."""
    vector_store_connected: bool = Field(..., description="Vector store connection status")
    vector_store_backend: str = Field(..., description="Vector store backend type")
    indexed_test_count: int = Field(0, description="Number of indexed test cases")
    sqe_agent_initialized: bool = Field(..., description="SQE agent initialization status")
    hybrid_generator_available: bool = Field(..., description="Hybrid generator availability")
    rag_retriever_available: bool = Field(..., description="RAG retriever availability")


class ExtendedHealthCheckResponse(BaseModel):
    """Extended health check including RAG components."""
    status: str = Field(..., description="Overall health status")
    model_loaded: bool = Field(..., description="HRM model loaded")
    model_checkpoint: Optional[str] = Field(None, description="Model checkpoint path")
    device: str = Field(..., description="Device (cpu/cuda)")
    uptime_seconds: float = Field(..., description="API uptime")
    version: str = Field(..., description="API version")
    rag_health: Optional[RAGHealthCheck] = Field(None, description="RAG system health")
